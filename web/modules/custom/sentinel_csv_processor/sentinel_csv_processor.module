<?php

/**
 * @file
 * Sentinel CSV Processor module.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\File\FileSystemInterface;

/**
 * Access callback for CSV upload form - allows admin and Socotec User roles.
 *
 * @param \Drupal\Core\Session\AccountInterface $account
 *   The user account.
 *
 * @return \Drupal\Core\Access\AccessResultInterface
 *   The access result.
 */
function sentinel_csv_processor_csv_upload_access(AccountInterface $account) {
  $roles = $account->getRoles();
  
  // Check for administrator role (admin).
  if (in_array('administrator', $roles)) {
    return AccessResult::allowed()->addCacheContexts(['user.roles']);
  }
  
  // Check for Socotec User role (case-insensitive check).
  $allowed_roles = ['socotec user', 'socotec_user', 'Socotec User'];
  foreach ($roles as $role) {
    if (in_array(strtolower($role), array_map('strtolower', $allowed_roles))) {
      return AccessResult::allowed()->addCacheContexts(['user.roles']);
    }
  }
  
  return AccessResult::forbidden()->addCacheContexts(['user.roles']);
}

/**
 * Implements hook_cron().
 *
 * Scans the automate-csvs/uploads directory and enqueues files for processing.
 */
function sentinel_csv_processor_cron() {
  // Log immediately to confirm hook is being called.
  \Drupal::logger('sentinel_csv_processor')->info('Cron hook called - START.');
  
  // Check if we ran recently (within last 3 minutes) to prevent duplicate runs.
  // This prevents our hook from running too frequently even if automated_cron triggers often.
  $state = \Drupal::state();
  $last_run = $state->get('sentinel_csv_processor.cron_last_run', 0);
  $current_time = \Drupal::time()->getRequestTime();
  $min_interval = 60; // 1 minutes minimum between runs (reduced from 10 to allow more frequent checks).
  
  if (($current_time - $last_run) < $min_interval) {
    // Skip this run - too soon since last execution.
    \Drupal::logger('sentinel_csv_processor')->info('Skipping cron run - only @seconds seconds since last run (minimum @min_interval).', [
      '@seconds' => $current_time - $last_run,
      '@min_interval' => $min_interval,
    ]);
    return;
  }
  
  \Drupal::logger('sentinel_csv_processor')->info('Cron hook proceeding - last run was @seconds seconds ago.', [
    '@seconds' => $current_time - $last_run,
  ]);
  
  // Record that we're starting (even if we fail, we don't want to retry immediately).
  $state->set('sentinel_csv_processor.cron_last_run', $current_time);

  // Set a maximum execution time for this cron hook (10 minutes).
  $max_execution_time = 600;
  $start_time = time();
  @set_time_limit($max_execution_time);

  try {
    $file_system = \Drupal::service('file_system');
    
    // Use private:// URI for the automate directory.
    $automate_dir_uri = 'private://lab_files/automate-csvs';
    $base_directory_uri = 'private://lab_files';
    
    // Get real path from URI.
    $automate_dir = $file_system->realpath($automate_dir_uri);
    $base_directory = $file_system->realpath($base_directory_uri);

    // Check timeout before proceeding.
    if ((time() - $start_time) >= $max_execution_time) {
      \Drupal::logger('sentinel_csv_processor')->warning('Cron hook timeout before processing.');
      return;
    }

    // Ensure directories exist.
    // automate-csvs should have 4 subdirectories: uploads, processing, archive, and failed.
    \Drupal::logger('sentinel_csv_processor')->info('Preparing directories...');
    $file_system->prepareDirectory($automate_dir_uri, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS);
    \Drupal::logger('sentinel_csv_processor')->info('Automate directory prepared.');
    // All subdirectories should be inside automate-csvs.
    $uploads_dir_uri = $automate_dir_uri . '/uploads';
    $processing_dir_uri = $automate_dir_uri . '/processing';
    $archive_dir_uri = $automate_dir_uri . '/archive';
    $failed_dir_uri = $automate_dir_uri . '/failed';
    $file_system->prepareDirectory($uploads_dir_uri, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS);
    \Drupal::logger('sentinel_csv_processor')->info('Uploads directory prepared.');
    $file_system->prepareDirectory($processing_dir_uri, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS);
    \Drupal::logger('sentinel_csv_processor')->info('Processing directory prepared.');
    $file_system->prepareDirectory($archive_dir_uri, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS);
    \Drupal::logger('sentinel_csv_processor')->info('Archive directory prepared.');
    $file_system->prepareDirectory($failed_dir_uri, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS);
    \Drupal::logger('sentinel_csv_processor')->info('Failed directory prepared.');

    // Check if directory exists.
    if (!$automate_dir || !is_dir($automate_dir)) {
      \Drupal::logger('sentinel_csv_processor')->warning('Automate CSV directory does not exist: @dir', [
        '@dir' => $automate_dir_uri,
      ]);
      return;
    }

  // Get queue.
  $queue = \Drupal::queue('automated_csv_processor');
  $entity_storage = \Drupal::entityTypeManager()->getStorage('lab_data');

  // Scan uploads directory for CSV files (files should be placed in automate-csvs/uploads/).
  $uploads_dir = $file_system->realpath($uploads_dir_uri);
  \Drupal::logger('sentinel_csv_processor')->info('Scanning uploads directory: @dir', ['@dir' => $uploads_dir ?: $uploads_dir_uri]);
  
  if (!$uploads_dir || !is_dir($uploads_dir)) {
    \Drupal::logger('sentinel_csv_processor')->warning('Uploads directory does not exist: @dir', [
      '@dir' => $uploads_dir_uri,
    ]);
    return;
  }
  
  $files = glob($uploads_dir . '/*.csv');
  \Drupal::logger('sentinel_csv_processor')->info('Glob found @count files.', ['@count' => count($files)]);
  
  if (empty($files)) {
    \Drupal::logger('sentinel_csv_processor')->info('No CSV files found in automate-csvs/uploads directory.');
    return;
  }
  
  \Drupal::logger('sentinel_csv_processor')->info('Found @count CSV files in automate-csvs/uploads directory.', [
    '@count' => count($files),
  ]);

  $enqueued_count = 0;
  $skipped_count = 0;

  // Limit the number of files processed per cron run to prevent overload.
  $max_files_per_run = 10;
  $files_processed = 0;

  // Get processing directory path once (outside loop) - inside automate-csvs.
  $processing_dir_uri = $automate_dir_uri . '/processing';
  $processing_dir = $file_system->realpath($processing_dir_uri);
  $processing_files = [];
  if ($processing_dir && is_dir($processing_dir)) {
    // Get list of files in processing directory once.
    $processing_files = array_flip(array_map('basename', glob($processing_dir . '/*.csv')));
  }

  // Collect all filenames first for batch query.
  $file_data = [];
  foreach ($files as $file_path) {
    if (!is_file($file_path)) {
      continue;
    }
    $filename = basename($file_path);
    $file_data[$filename] = [
      'path' => $file_path,
      'mtime' => filemtime($file_path),
    ];
  }

  if (empty($file_data)) {
    return;
  }

  // Batch query: get all existing lab_data entities for these filenames in one query.
  \Drupal::logger('sentinel_csv_processor')->info('Querying database for @count filenames.', ['@count' => count($file_data)]);
  $query = $entity_storage->getQuery()
    ->accessCheck(FALSE)
    ->condition('filename', array_keys($file_data), 'IN');
  $existing_ids = $query->execute();
  \Drupal::logger('sentinel_csv_processor')->info('Found @count existing entities.', ['@count' => count($existing_ids)]);

  // Load all entities at once (batch load).
  \Drupal::logger('sentinel_csv_processor')->info('Loading @count entities.', ['@count' => count($existing_ids)]);
  $existing_entities = [];
  if (!empty($existing_ids)) {
    $existing_entities = $entity_storage->loadMultiple($existing_ids);
    // Index by filename for quick lookup.
    $existing_by_filename = [];
    foreach ($existing_entities as $entity) {
      $existing_by_filename[$entity->get('filename')->value] = $entity;
    }
    $existing_entities = $existing_by_filename;
  }
  \Drupal::logger('sentinel_csv_processor')->info('Loaded and indexed @count entities.', ['@count' => count($existing_entities)]);

  // Process each file.
  foreach ($file_data as $filename => $data) {
    // Check timeout during processing.
    if ((time() - $start_time) >= $max_execution_time) {
      \Drupal::logger('sentinel_csv_processor')->warning('Cron hook timeout during file processing. Stopping early.');
      break;
    }

    $file_path = $data['path'];
    $file_mtime = $data['mtime'];

    $should_process = TRUE;
    $skip_reason = '';
    
    // Check if entity exists.
    if (isset($existing_entities[$filename])) {
      $lab_data = $existing_entities[$filename];
      $stored_mtime = $lab_data->get('ftp_file_updated')->value;
      $status = $lab_data->get('status')->value;
      $process_type = $lab_data->get('process_type')->value;
      
      // Skip if already processed with matching modification date.
      if ($stored_mtime && (int) $stored_mtime === (int) $file_mtime) {
        $should_process = FALSE;
        $skip_reason = 'matching mtime';
        $skipped_count++;
        \Drupal::logger('sentinel_csv_processor')->info('Skipping @file: @reason (stored: @stored, file: @file_mtime)', [
          '@file' => $filename,
          '@reason' => $skip_reason,
          '@stored' => $stored_mtime,
          '@file_mtime' => $file_mtime,
        ]);
        continue;
      }
      // Skip if currently being processed (status = processing and process_type = automate).
      if ($status === 'processing' && $process_type === 'automate') {
        $should_process = FALSE;
        $skip_reason = 'currently processing';
        $skipped_count++;
        \Drupal::logger('sentinel_csv_processor')->info('Skipping @file: @reason', [
          '@file' => $filename,
          '@reason' => $skip_reason,
        ]);
        continue;
      }
    }

    // Check if file is already in processing directory (quick lookup).
    if (isset($processing_files[$filename])) {
      $should_process = FALSE;
      $skip_reason = 'in processing directory';
      $skipped_count++;
      \Drupal::logger('sentinel_csv_processor')->info('Skipping @file: @reason', [
        '@file' => $filename,
        '@reason' => $skip_reason,
      ]);
      continue;
    }

    if ($should_process) {
      // Limit files processed per cron run.
      if ($files_processed >= $max_files_per_run) {
        \Drupal::logger('sentinel_csv_processor')->info('Reached maximum files per cron run (@max). Remaining files will be processed in next cron run.', [
          '@max' => $max_files_per_run,
        ]);
        break;
      }

      // Move file from uploads to processing (month/year subdirectory).
      $processing_target_dir = _sentinel_csv_processor_prepare_directory_with_month_year($processing_dir_uri);
      if (!$processing_target_dir) {
        \Drupal::logger('sentinel_csv_processor')->error('Failed to prepare processing directory for @file. Skipping enqueue.', [
          '@file' => $filename,
        ]);
        continue;
      }

      $processing_target_path = $file_system->realpath($processing_target_dir);
      if (!$processing_target_path) {
        \Drupal::logger('sentinel_csv_processor')->error('Could not resolve processing path for @file. Skipping enqueue.', [
          '@file' => $filename,
        ]);
        continue;
      }

      $processing_target_file = $processing_target_path . '/' . $filename;
      if (file_exists($processing_target_file)) {
        @unlink($processing_target_file);
      }

      if (!@rename($file_path, $processing_target_file)) {
        if (!@copy($file_path, $processing_target_file)) {
          \Drupal::logger('sentinel_csv_processor')->error('Failed to move @file from uploads to processing. Skipping enqueue.', [
            '@file' => $filename,
          ]);
          continue;
        }
        @unlink($file_path);
      }

      $processing_target_uri = $processing_target_dir . '/' . $filename;

      // Enqueue file for processing.
      // file_uri should point to the file in processing directory.
      $item_id = $queue->createItem([
        'file_path' => $processing_target_file,
        'file_uri' => $processing_target_uri,
        'filename' => $filename,
        'file_mtime' => $file_mtime,
        'automate_dir_uri' => $automate_dir_uri,
      ]);
      
      if ($item_id) {
        $enqueued_count++;
        $files_processed++;
        \Drupal::logger('sentinel_csv_processor')->info('Enqueued file @file for automated processing (item ID: @id).', [
          '@file' => $filename,
          '@id' => $item_id,
        ]);
      }
      else {
        \Drupal::logger('sentinel_csv_processor')->error('Failed to enqueue file @file - createItem returned FALSE.', [
          '@file' => $filename,
        ]);
      }
    }
  }

    if ($enqueued_count > 0 || $skipped_count > 0) {
      \Drupal::logger('sentinel_csv_processor')->info('Cron scan completed: @enqueued files enqueued, @skipped files skipped.', [
        '@enqueued' => $enqueued_count,
        '@skipped' => $skipped_count,
      ]);
    }
  }
  catch (\Exception $e) {
    // Log the exception but don't let it prevent cron from completing.
    \Drupal::logger('sentinel_csv_processor')->error('Exception in cron hook: @message', [
      '@message' => $e->getMessage(),
    ]);
    // Don't re-throw - let cron complete normally.
  }
  catch (\Throwable $e) {
    // Catch any other errors (PHP 7+).
    \Drupal::logger('sentinel_csv_processor')->error('Error in cron hook: @message', [
      '@message' => $e->getMessage(),
    ]);
  }
}

/**
 * Implements hook_sentinel_sendresults().
 *
 * NOTE: This hook is no longer used for file movement logic.
 * File movement is now handled directly in AutomatedCsvQueueWorker
 * after automated_csv_processor completes (success -> archive, fail -> failed).
 *
 * @param object $sample_entity
 *   The sentinel_sample entity that was processed.
 */
function sentinel_csv_processor_sentinel_sendresults($sample_entity) {
  // No-op: File movement is handled in AutomatedCsvQueueWorker.
  // This hook is kept for compatibility but does nothing.
  return;
}

/**
 * Helper function to prepare directory with month/year subdirectory.
 *
 * @param string $base_dir_uri
 *   The base directory URI.
 *
 * @return string|false
 *   The full directory URI with month/year subdirectory, or FALSE on failure.
 */
function _sentinel_csv_processor_prepare_directory_with_month_year($base_dir_uri) {
  $file_system = \Drupal::service('file_system');
  $timestamp = \Drupal::time()->getRequestTime();
  $month = (int) date('n', $timestamp);
  $year = (int) date('Y', $timestamp);
  $month_year = $month . '-' . $year;
  $full_dir_uri = $base_dir_uri . '/' . $month_year;

  $prepared = $file_system->prepareDirectory($full_dir_uri, FileSystemInterface::CREATE_DIRECTORY | FileSystemInterface::MODIFY_PERMISSIONS);
  if (!$prepared) {
    $dir_path = $file_system->realpath($full_dir_uri);
    if ($dir_path && !is_dir($dir_path)) {
      @mkdir($dir_path, 0775, TRUE);
    }
    $dir_path = $file_system->realpath($full_dir_uri);
    if (!$dir_path || !is_dir($dir_path)) {
      return FALSE;
    }
  }

  return $full_dir_uri;
}

/**
 * Implements hook_mail().
 */
function sentinel_csv_processor_mail($key, &$message, $params) {
  \Drupal::logger('sentinel_csv_processor')->info('sentinel_csv_processor_mail invoked for key @key.', [
    '@key' => $key,
  ]);
  switch ($key) {
    case 'csv_processing_error':
      $context = $params['context'] ?? 'unknown';
      $from = $params['from'] ?? $message['from'] ?? '';
      $reply_to = $params['reply_to'] ?? $from;
      $message['subject'] = t('CSV processing error (@context)', ['@context' => $context]);
      if (!empty($from)) {
        $message['from'] = $from;
      }
      if (!empty($reply_to)) {
        $message['headers']['Reply-To'] = $reply_to;
      }
      \Drupal::logger('sentinel_csv_processor')->info('CSV mail headers: to=@to from=@from subject=@subject', [
        '@to' => $message['to'] ?? '',
        '@from' => $message['from'] ?? '',
        '@subject' => $message['subject'],
      ]);

      $lines = [];
      if ($context === 'queue') {
        $filename = $params['filename'] ?? 'unknown';
        $error = $params['error'] ?? 'Unknown error';
        $lines[] = 'An automated CSV file failed to process.';
        $lines[] = 'Filename: ' . $filename;
        $lines[] = 'Error: ' . $error;
      }
      else {
        $lines[] = 'One or more CSV files failed during batch processing.';
        $errors = $params['errors'] ?? [];
        if (!empty($errors)) {
          $lines[] = '';
          $lines[] = 'Errors:';
          foreach ($errors as $error) {
            $lines[] = '- ' . $error;
          }
        }
      }

      $message['body'] = $lines;
      break;
  }
}
